<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.30">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kei Taketsuna">
<meta name="dcterms.date" content="2025-03-23">
<meta name="description" content="How to explore and evaluate a data analysis topic with an automated conversational framework?">

<title>Anomaly Detection in Time Series using ChatGPT – My exploration of capabilities of LLMs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-de070a7b0ab54f8780927367ac907214.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-630147fbe0b9ab2b2a517857e522e257.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My exploration of capabilities of LLMs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/keitake123"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Anomaly Detection in Time Series using ChatGPT</h1>
                  <div>
        <div class="description">
          How to explore and evaluate a data analysis topic with an automated conversational framework?
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">LLMs</div>
                <div class="quarto-category">Informal Reasoning</div>
                <div class="quarto-category">Formal Reasoning</div>
                <div class="quarto-category">Talk</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Kei Taketsuna </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 23, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>This is based on a post on the Medium that I found really intresting. <br> https://medium.com/<span class="citation" data-cites="sztistvan/anomaly-detection-in-time-series-using-chatgpt-3fc48f958c88">@sztistvan/anomaly-detection-in-time-series-using-chatgpt-3fc48f958c88</span></p>
<pre><code># **Example**

&gt; **_QUERY_**_: Create an example to demonstrate anomaly detection in time series data. Use Python without any specific package._
_Remark_: When I posed this question across different sessions, responses varied, sometimes using specific packages such as Prophet, and sometimes sticking only to packages like NumPy and Pandas. Hence, I made it clear not to employ additional packages.
Here’s the response I received:

&gt; **_ChatGPT_**_: For this example, I’ll use the _Numenta Anomaly Benchmark (NAB)_ dataset, which offers various real-world time series data with labeled anomalies. Specifically, I’ll utilize the “machine_temperature_system_failure.csv” dataset, which contains temperature readings from a machine in an industrial context._

&gt; _I’ll perform anomaly detection on this dataset using a simple statistical approach called the _Moving Average (MA)_ technique. This technique computes the moving average of the data over a given window and detects anomalies via deviations from this moving average._
```python
import pandas as pd
import matplotlib.pyplot as plt
# Load the dataset
df = pd.read_csv('https://raw.githubusercontent.com/numenta/NAB/master/data/realKnownCause/machine_temperature_system_failure.csv')
# Convert the timestamp column to a datetime object
df['timestamp'] = pd.to_datetime(df['timestamp'])
# Compute the moving average of the temperature readings
window_size = 200 # MODIFICATION, originally 50
ma = df['value'].rolling(window_size).mean()
# Calculate the deviation from the moving average
deviation = df['value'] - ma
# Calculate the standard deviation of the deviation
std_deviation = deviation.rolling(window_size).std()
# Determine the threshold for anomaly detection
threshold = 3 * std_deviation
# Identify anomalies based on deviations from the moving average
anomalies = df[deviation.abs() &gt; threshold]
# Plot the temperature readings and the anomalies
plt.subplots(figsize=(14, 10)) # MODIFICATION, inserted
plt.plot(df['timestamp'], df['value'], color='blue', label='Temperature Readings')
plt.scatter(anomalies['timestamp'], anomalies['value'], color='red', label='Anomalies')
plt.plot(df['timestamp'], ma, color='green', label='Moving Average')
plt.fill_between(df['timestamp'], ma-threshold, ma+threshold, color='gray', alpha=0.2, label='Threshold')
plt.legend()
plt.title('Machine Temperature Anomaly Detection')
plt.xlabel('Date')
plt.ylabel('Temperature (Celsius)')
plt.grid() # MODIFICATION, inserted
plt.show()

Remark: I made simple modifications, adjusting the time window parameter, and added lines to improve plot visuals. &lt;br&gt;

This basic anomaly detection yields several insights:&lt;br&gt;
&lt;br&gt;
We accessed real-world data using the NAB dataset. You can obtain information about this dataset through ChatGPT by asking: “What is the Numenta Anomaly Benchmark (NAB) dataset and how can I access it?” or search sites like Google and Kaggle for examples and studies.
We employed a straightforward approach using a moving average calculated with a moving window operator and set thresholds based on data deviations from this average.
We added visualization enhancements, such as clearly displaying the anomaly detection threshold with shaded gray regions.
Despite the simplicity, it was achieved quickly.
Although the results weren't optimal, this issue is manageable at this stage. We can delve into parameter tuning:
Asking about setting the parameters
It's clear that this is a commonly accepted rule of thumb in statistics and data assessment for defining thresholds, especially in identifying extreme values or outliers. Let's explore some variations.

## Z-score
To further enhance detection, we might calculate deviations from the mean and compare these to the standard deviation, essentially applying the Z-score. This Z-score shows how many standard deviations a given value is from the mean. By adjusting the code, we can approach it thus:
</code></pre>
<section id="calculate-the-average-of-the-temperature-readings" class="level1">
<h1>Calculate the average of the temperature readings</h1>
<p>mean = df[‘value’].mean() # Compute the deviation from the average deviation = df[‘value’] - mean # Determine the standard deviation of the deviation std_deviation = deviation.std() # equivalent to df[‘value’].std() # Compute the Z-score - for reference but not directly used z_score = deviation / std_deviation # z_score = (value-mean)/std # Establish the threshold for anomaly detection threshold = 3 * std_deviation # Identify anomalies based on deviations from the moving average anomalies = df[deviation.abs() &gt; threshold]</p>
<p>Anomaly detection founded on Z-score</p>
<section id="percentiles" class="level2">
<h2 class="anchored" data-anchor-id="percentiles">Percentiles <br></h2>
<p>We can define global upper and lower limits, leveraging the percentage distribution of the data values. Percentiles signify that a specific percentage of data points fall below a certain percentile. For instance, the 50th percentile represents the median. To define lower and upper bounds encompassing 99.7% of the data, apply the following code:</p>
<pre><code># calculate percentile limits
percent_limit = 0.3 # 99.7% is set
upper_threshold = df['value'].quantile((100-percent_limit/2)/100) 
lower_threshold = df['value'].quantile(percent_limit/2/100) 
# Detect anomalies based on percentile limits
anomalies_upper = df[df['value'] &gt; upper_threshold]
anomalies_lower = df[df['value'] &lt; lower_threshold]


## Anomaly detection using percentiles

It's crucial now to clarify the concept of an anomaly.

## Anomaly Detection
We immediately dive into differentiating between anomaly detection and change point detection:

Anomaly detection in time series:

Anomalies typically signify potential issues in the underlying system or process generating the data.
It involves pinpointing data points or occurrences significantly deviating from anticipated or typical series behavior.
Change point detection in time series:

Change points typically represent notable transitions in the underpinning system or process producing the data.
This involves identifying time points where the series' statistical attributes abruptly alter.
The crux is that anomaly detection zooms in on individual points or events deviating from expected norms, whereas change point detection focuses on temporal points where the series' statistical facets shift.

A straightforward way to remember:

Persistent anomalies are change points. 

Consider monitoring system measurements as a continuous series. Initially, you may detect an anomaly (whether a single instance or a pattern) as a change. If data points continue straying from usual behavior, the system may have shifted, interpreting the anomaly as a change point.

Types of Anomalies
A pertinent discussion involves types of anomalies. Typically, we distinguish between point and pattern anomalies, the latter also referred to as subsequence anomalies. Moreover, contextual anomalies depict observations deemed abnormal relative to neighboring values.

QUERY: What types of anomalies are in time series?

ChatGPT: In time series analysis, several types of anomalies can arise, including:

1. Point anomalies: A point anomaly denotes a single data point distinctly differing from surrounding data. Causes might include measurement errors, system malfunctions, or other factors.

2. Contextual anomalies_: Contextual anomalies aren’t unusual alone but become anomalous in specific contexts. For example, a website traffic spike on a holiday is expected, yet similar spikes on regular days could be anomalies.

3. Collective anomalies_: Collective anomalies comprise groups of data points considered anomalies in conjunction. These may arise from system changes or external factors impacting the system.

4. Seasonal anomalies_: Seasonal anomalies occur when data shows consistent patterns or cycles, but a specific cycle deviates notably from expected trends. Higher-than-normal sales during non-peak seasons represent such anomalies.

5. Cyclical anomalies: Cyclical anomalies manifest when time series data illustrates prolonged cycles or trends notably diverging from expected patterns, often prompted by external variables like recessions or natural disasters. 

Remark: In the context of collective anomalies, the notion of pattern anomalies is evident.

With these concepts clarified, we generated an example to illustrate both anomalies and change points:
Time series with both change points and anomalies focus

Algorithms for Anomaly Detection
So far, we've explored applying a simple moving average approach and touched on statistical methods. Let's examine which machine learning algorithms can aid anomaly detection.

QUERY: What specific machine learning algorithms are for anomaly detection? 

Summarizing various responses across sessions:

ChatGPT: Numerous machine learning algorithms exist for anomaly detection in time series.

1. Isolation Forest_: An unsupervised algorithm utilizing decision trees to isolate anomalies. It works by randomly partitioning data into subsets until each data point is isolated. Fewer partitions indicate higher anomaly likelihood.

2. Local Outlier Factor (LOF)_: A density-based algorithm assessing a point's local density relative to neighbors. Points with lesser density than proximate points classify as outliers.

3. One-Class Support Vector Machine (SVM)_: This SVM variation is trained on just one data class, learning a boundary separating training data from the origin, considering any point crossing this boundary as an anomaly.

4. LSTM-based models_: LSTM, a type of Recurrent Neural Network (RNN), excels in modeling sequences, aiding anomaly detection by learning intricate patterns over time.

5. Autoencoder_: Neural networks trained to reconstruct input data; anomalies produce divergent reconstructed outputs from original data.

6. ARIMA (AutoRegressive Integrated Moving Average)__: Primarily for forecasting, ARIMA extends to anomaly detection by comparing predicted and actual values.

7. Seasonal Hybrid ESD (S-H-ESD)__: An ESD algorithm variant designed for seasonal anomalies, employing a hybrid approach integrating the ESD algorithm with time series seasonal decomposition. 

Isolation Forest
Isolation Forest represents an unsupervised machine learning approach utilizing decision tree ensembles to isolate anomalies within data.

QUERY: Create a python function applying the Isolation Forest algorithm to detect time series anomalies. The function input is a Pandas series. 
</code></pre>
<p>import pandas as pd from sklearn.ensemble import IsolationForest def detect_anomalies_with_isolation_forest(series): # Convert the series to a 2D NumPy array data = series.values.reshape(-1, 1)</p>
<pre><code># Create an instance of the IsolationForest class
#model = IsolationForest(n_estimators=100, contamination='auto', random_state=42)
model = IsolationForest(n_estimators=100, contamination=0.1, random_state=42)
# Fit the model to the data and predict anomalies
model.fit(data)
anomalies = model.predict(data)

# Convert the predictions back to a Pandas series and return it
anomalies_series = pd.Series(anomalies, index=series.index)
return anomalies_series</code></pre>
<p>Plotting the results:</p>
<pre><code># Set the timestamp column as the index and convert to a series
series = df.set_index('timestamp')['value'].squeeze()
# Detect anomalies using the Isolation Forest algorithm
anomalies = detect_anomalies_with_isolation_forest(series)
# Plot the original series and the detected anomalies
plt.subplots(figsize=(14, 10)) 
plt.plot(df['timestamp'], df['value'], color='blue', label='Temperature Readings')
plt.scatter(anomalies[anomalies==-1].index, series[anomalies==-1].values, color='red', label='Anomalies')
plt.legend()
plt.title('Machine Temperature Anomaly Detection - Isolation Forest')
plt.xlabel('Date')
plt.ylabel('Temperature (Celsius)')
plt.grid()
plt.show()

By replacing the parameter contamination ‘auto‘ with a value of 0.1 and observing the results: &lt;br&gt;
Isolation Forest example&lt;br&gt;
Unlike using the Z-score method, detected points align more closely with local irregularities.

Querying for deeper Isolation Forest parameter explanations:&lt;br&gt;

Local Outlier Factor&lt;br&gt;
Local Outlier Factor (LOF) is an unsupervised anomaly detection algorithm gauging a point's local density relative to neighbors, based on the premise that anomalies naturally reside in low-density regions.
</code></pre>
<p>import pandas as pd from sklearn.neighbors import LocalOutlierFactor def detect_anomalies_with_local_outlier(series): #lof = LocalOutlierFactor(n_neighbors=10, contamination=‘auto’) lof = LocalOutlierFactor(n_neighbors=40, contamination=0.01) X = series.values.reshape(-1,1) y_pred = lof.fit_predict(X) anomalies = X[y_pred==-1] return pd.Series(anomalies.flatten(), index=series.index[y_pred==-1])</p>
<pre><code># Detect anomalies using the Isolation Forest algorithm
anomalies = detect_anomalies_with_local_outlier(series)
# Plot the original series and the detected anomalies
plt.subplots(figsize=(14, 10)) 
plt.plot(df['timestamp'], df['value'], color='blue', label='Temperature Readings')
plt.scatter(anomalies.index, anomalies.values, color='red', label='Anomalies')
plt.legend()
plt.title('Machine Temperature Anomaly Detection - Local Outlier Factor')
plt.xlabel('Date')
plt.ylabel('Temperature (Celsius)')
plt.grid()
plt.show()

Local Outlier Factor illustrated
Parameters include two primary settings: n_neighbors and contamination.

Autoencoder Algorithm
Autoencoders are unsupervised machine learning models based on neural networks. They comprise two main parts: a) encoder and b) decoder. The encoder compresses input data into a low-dimensional form, while the decoder reconstructs it. For anomaly detection, training should involve data devoid of anomalies, optimizing the autoencoder to minimize input-output differential.

In anomaly contexts, training models on test data allows identifying anomalies via high reconstruction errors.

Here’s an autoencoder model code generated by ChatGPT:
</code></pre>
<p>import numpy as np import pandas as pd from tensorflow import keras def detect_anomalies_with_autoencoder(series, window_size=20, latent_dim=3, epochs=100): # Prepare the input data X = [] for i in range(len(series) - window_size): X.append(series[i:i+window_size]) X = np.array(X)</p>
<pre><code># Define the autoencoder architecture
model = keras.Sequential([
    keras.layers.Dense(64, activation='relu', input_shape=(window_size,)),
    keras.layers.Dense(latent_dim, activation='relu'),
    keras.layers.Dense(64, activation='relu'),
    keras.layers.Dense(window_size, activation='linear')
])

# Train the autoencoder
model.compile(optimizer='adam', loss='mse')
model.fit(X, X, epochs=epochs, verbose=0)

# Use the trained autoencoder to detect anomalies
X_pred = model.predict(X)
mse = np.mean(np.power(X - X_pred, 2), axis=1)
threshold = np.percentile(mse, 95)
anomalies = series.iloc[window_size:][mse &gt;= threshold]

return anomalies</code></pre>
<p>As mentioned earlier, “blind” application might make it seem like a near-“perfect” solution. 😂 Examine the code (access link at the conclusion).</p>
<p>ARIMA example</p>
<p>Notice that the overlap between training and test sets is deliberate to observe model behavior on historical data.</p>
<p>However, using the ARIMA model properly warrants cautious preparation. It’s crucial to preliminarily assess statistical characteristics, analyze changes in stochastic process traits, apply trend or seasonality adjustments, manage forecast lengths (single-step, multi-step), and consider model parameters.</p>
<p>We now have a preliminary grasp of leveraging ChatGPT for data analysis topic exploration. Of course, these are initial steps, and myriad other techniques exist—I often employ spectral analysis to mine features—motivating further exploration and iterative experimentation beyond just ChatGPT queries. Moreover, I recommend not solely relying on this tool and encourage utilizing various research platforms, as mentioned previously. Nonetheless, ChatGPT can significantly expedite processes.</p>
<p>Summary and Conclusion This guide illustrates leveraging ChatGPT in exploring a specific data analysis topic. Utilized ChatGPT to understand anomaly detection in time series data. Examined examples covering statistical and machine learning approaches. Clarified differences between anomaly and change point detection. Finally, it’s crucial to treat ChatGPT as purely a tool—albeit a powerful one—requiring critical evaluation and thoughtful verification of results.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/keitake123\.github\.io\/comm4190_S25_Using_LLMs_Blog\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>